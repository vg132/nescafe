using OpenTK.Mathematics;
using OpenTK.WinForms;
using OpenTK.Graphics.OpenGL4;

namespace Nescafe.UI;

public class Renderer
{
	private readonly GLControl _control;

	private System.Windows.Forms.Timer _timer;
	private float _angle = 0.0f;

	public Renderer(GLControl control)
	{
		_control = control;
		Setup();
	}

	private static readonly Vector3[] VertexData = new Vector3[]
	{
						new Vector3(-1.0f, -1.0f, -1.0f),
						new Vector3(-1.0f, 1.0f, -1.0f),
						new Vector3(1.0f, 1.0f, -1.0f),
						new Vector3(1.0f, -1.0f, -1.0f),

						new Vector3(-1.0f, -1.0f, -1.0f),
						new Vector3(1.0f, -1.0f, -1.0f),
						new Vector3(1.0f, -1.0f, 1.0f),
						new Vector3(-1.0f, -1.0f, 1.0f),

						new Vector3(-1.0f, -1.0f, -1.0f),
						new Vector3(-1.0f, -1.0f, 1.0f),
						new Vector3(-1.0f, 1.0f, 1.0f),
						new Vector3(-1.0f, 1.0f, -1.0f),

						new Vector3(-1.0f, -1.0f, 1.0f),
						new Vector3(1.0f, -1.0f, 1.0f),
						new Vector3(1.0f, 1.0f, 1.0f),
						new Vector3(-1.0f, 1.0f, 1.0f),

						new Vector3(-1.0f, 1.0f, -1.0f),
						new Vector3(-1.0f, 1.0f, 1.0f),
						new Vector3(1.0f, 1.0f, 1.0f),
						new Vector3(1.0f, 1.0f, -1.0f),

						new Vector3(1.0f, -1.0f, -1.0f),
						new Vector3(1.0f, 1.0f, -1.0f),
						new Vector3(1.0f, 1.0f, 1.0f),
						new Vector3(1.0f, -1.0f, 1.0f),
	};

	private static readonly int[] IndexData = new int[]
	{
						 0,  1,  2,  2,  3,  0,
						 4,  5,  6,  6,  7,  4,
						 8,  9, 10, 10, 11,  8,
						12, 13, 14, 14, 15, 12,
						16, 17, 18, 18, 19, 16,
						20, 21, 22, 22, 23, 20,
	};

	private static readonly Color4[] ColorData = new Color4[]
	{
						Color4.Silver, Color4.Silver, Color4.Silver, Color4.Silver,
						Color4.Honeydew, Color4.Honeydew, Color4.Honeydew, Color4.Honeydew,
						Color4.Moccasin, Color4.Moccasin, Color4.Moccasin, Color4.Moccasin,
						Color4.IndianRed, Color4.IndianRed, Color4.IndianRed, Color4.IndianRed,
						Color4.PaleVioletRed, Color4.PaleVioletRed, Color4.PaleVioletRed, Color4.PaleVioletRed,
						Color4.ForestGreen, Color4.ForestGreen, Color4.ForestGreen, Color4.ForestGreen,
	};

	private const string VertexShaderSource = @"#version 330 core

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec4 aColor;

out vec4 fColor;

uniform mat4 MVP;

void main()
{
    gl_Position = vec4(aPos, 1) * MVP;
    fColor = aColor;
}
";

	private const string FragmentShaderSource = @"#version 330 core

in vec4 fColor;

out vec4 oColor;

void main()
{
    oColor = fColor;
}
";

	private int CubeShader;

	private int VAO;
	private int EBO;
	private int PositionBuffer;
	private int ColorBuffer;

	private void Setup()
	{
		// Make sure that when the GLControl is resized or needs to be painted,
		// we update our projection matrix or re-render its contents, respectively.
		_control.Resize += glControl_Resize;
		_control.Paint += glControl_Paint;

		// Redraw the screen every 1/20 of a second.
		_timer = new System.Windows.Forms.Timer();
		_timer.Tick += (sender, e) =>
		{
			const float DELTA_TIME = 1 / 50f;
			_angle += 180f * DELTA_TIME;
			Render();
		};
		_timer.Interval = 50;   // 1000 ms per sec / 50 ms per frame = 20 FPS
		_timer.Start();

		// Ensure that the viewport and projection matrix are set correctly initially.
		glControl_Resize(_control, EventArgs.Empty);

		CubeShader = CompileProgram(VertexShaderSource, FragmentShaderSource);

		VAO = GL.GenVertexArray();
		GL.BindVertexArray(VAO);

		EBO = GL.GenBuffer();
		GL.BindBuffer(BufferTarget.ElementArrayBuffer, EBO);
		GL.BufferData(BufferTarget.ElementArrayBuffer, IndexData.Length * sizeof(int), IndexData, BufferUsageHint.StaticDraw);

		PositionBuffer = GL.GenBuffer();
		GL.BindBuffer(BufferTarget.ArrayBuffer, PositionBuffer);
		GL.BufferData(BufferTarget.ArrayBuffer, VertexData.Length * sizeof(float) * 3, VertexData, BufferUsageHint.StaticDraw);

		GL.EnableVertexAttribArray(0);
		GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, sizeof(float) * 3, 0);

		ColorBuffer = GL.GenBuffer();
		GL.BindBuffer(BufferTarget.ArrayBuffer, ColorBuffer);
		GL.BufferData(BufferTarget.ArrayBuffer, ColorData.Length * sizeof(float) * 4, ColorData, BufferUsageHint.StaticDraw);

		GL.EnableVertexAttribArray(1);
		GL.VertexAttribPointer(1, 4, VertexAttribPointerType.Float, false, sizeof(float) * 4, 0);
	}

	private int CompileProgram(string vertexShader, string fragmentShader)
	{
		int program = GL.CreateProgram();

		int vert = CompileShader(ShaderType.VertexShader, vertexShader);
		int frag = CompileShader(ShaderType.FragmentShader, fragmentShader);

		GL.AttachShader(program, vert);
		GL.AttachShader(program, frag);

		GL.LinkProgram(program);

		GL.GetProgram(program, GetProgramParameterName.LinkStatus, out int success);
		if (success == 0)
		{
			string log = GL.GetProgramInfoLog(program);
			throw new Exception($"Could not link program: {log}");
		}

		GL.DetachShader(program, vert);
		GL.DetachShader(program, frag);

		GL.DeleteShader(vert);
		GL.DeleteShader(frag);

		return program;

		static int CompileShader(ShaderType type, string source)
		{
			int shader = GL.CreateShader(type);

			GL.ShaderSource(shader, source);
			GL.CompileShader(shader);

			GL.GetShader(shader, ShaderParameter.CompileStatus, out int status);
			if (status == 0)
			{
				string log = GL.GetShaderInfoLog(shader);
				throw new Exception($"Failed to compile {type}: {log}");
			}

			return shader;
		}
	}

	private void glControl_Resize(object? sender, EventArgs e)
	{
		_control.MakeCurrent();
		if (_control.ClientSize.Height == 0)
		{
			_control.ClientSize = new Size(_control.ClientSize.Width, 1);
		}
		GL.Viewport(0, 0, _control.ClientSize.Width, _control.ClientSize.Height);

		float aspect_ratio = Math.Max(_control.ClientSize.Width, 1) / (float)Math.Max(_control.ClientSize.Height, 1);
		projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4, aspect_ratio, 1, 64);
	}

	private void glControl_Paint(object sender, PaintEventArgs e)
	{
		Render();
	}

	Matrix4 projection;

	private void Render()
	{
		_control.MakeCurrent();

		GL.ClearColor(Color4.MidnightBlue);
		GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);

		GL.Enable(EnableCap.DepthTest);

		Matrix4 lookat = Matrix4.LookAt(0, 5, 5, 0, 0, 0, 0, 1, 0);
		Matrix4 model = Matrix4.CreateFromAxisAngle(new Vector3(0.0f, 1.0f, 0.0f), MathHelper.DegreesToRadians(_angle));

		Matrix4 mvp = model * lookat * projection;

		GL.UseProgram(CubeShader);
		GL.UniformMatrix4(GL.GetUniformLocation(CubeShader, "MVP"), true, ref mvp);


		GL.DrawElements(BeginMode.Triangles, IndexData.Length, DrawElementsType.UnsignedInt, 0);

		_control.SwapBuffers();
	}
}
